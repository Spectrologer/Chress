/**
 * TypeChecks - Standardized type checking utilities for the Chesse codebase
 *
 * ⚠️  THIS FILE IS AUTO-GENERATED - DO NOT EDIT DIRECTLY
 * Generated by: utils/generateTypeChecks.ts
 * To modify: Edit the configuration in generateTypeChecks.ts and regenerate
 *
 * PROBLEM SOLVED:
 * This module eliminates 111 instances of inconsistent type checking patterns:
 * - 29 instances of verbose `typeof tile === 'object' && tile !== null` checks
 * - 102 instances of direct `tile === TILE_TYPES.X` comparisons
 * - 123 instances already using proper `isTileType()` pattern
 *
 * RECOMMENDED USAGE:
 * ✅ GOOD: TileTypeChecker.isBomb(tile), TileTypeChecker.isTileObject(tile)
 * ✅ GOOD: EntityTypeChecker.isPenne(tile), EntityTypeChecker.isNPC(tile)
 * ❌ BAD:  typeof tile === 'object' && tile !== null && tile.type === TILE_TYPES.BOMB
 * ❌ BAD:  tile === TILE_TYPES.BOMB (when tile could be an object)
 *
 * Import and use these utilities throughout the codebase for consistent type checking.
 */

import { TILE_TYPES } from '@core/constants/index';

// ========================================
// TILE TYPE CHECKER CLASS
// ========================================

/**
 * TileTypeChecker - Handles all tile-related type checking
 * Includes terrain, items, structures, and interactive objects
 */
export class TileTypeChecker {
    // ========================================
    // CORE TYPE UTILITIES
    // ========================================

    /**
     * Normalizes a tile to its type value.
     * Handles both primitive tile types (numbers) and tile objects.
     *
     * This is the foundation for all type checking in the codebase.
     *
     * @param tile - Tile value or object
     * @returns The tile type number, or undefined if invalid
     *
     * @example
     * TileTypeChecker.getTileType(TILE_TYPES.FLOOR)                    // → 0
     * TileTypeChecker.getTileType({ type: TILE_TYPES.BOMB })           // → 24
     * TileTypeChecker.getTileType(null)                                // → undefined
     */
    static getTileType(tile: any): number | undefined {
        if (tile === null || tile === undefined) {
            return undefined;
        }

        if (typeof tile === 'object') {
            return tile.type;
        }

        return tile;
    }

    /**
     * Checks if a tile is a valid tile object (not just a primitive type).
     * Replaces the verbose pattern: `typeof tile === 'object' && tile !== null`
     *
     * USE THIS WHEN:
     * - You need to access tile properties like `tile.actionsSincePlaced`
     * - You need to validate a tile is an object before accessing object-specific data
     * - You're performing defensive checks before object property access
     *
     * @param tile - Value to check
     * @returns True if tile is a valid object with a type property
     *
     * @example
     * // ❌ BAD - Verbose pattern
     * if (tapTile && typeof tapTile === 'object' && tapTile !== null) {
     *     return tapTile.actionsSincePlaced > 0;
     * }
     *
     * // ✅ GOOD - Clean pattern
     * if (TileTypeChecker.isTileObject(tapTile)) {
     *     return tapTile.actionsSincePlaced > 0;
     * }
     */
    static isTileObject(tile: any): boolean {
        return tile !== null && typeof tile === 'object' && tile.type !== undefined;
    }

    /**
     * Checks if a tile has the specified type.
     * Handles both primitive tiles and tile objects seamlessly.
     *
     * This is the recommended way to check tile types throughout the codebase.
     *
     * @param tile - Tile to check
     * @param tileType - Expected TILE_TYPES value
     * @returns True if tile matches the specified type
     *
     * @example
     * // Works with primitive tiles
     * TileTypeChecker.isTileType(TILE_TYPES.BOMB, TILE_TYPES.BOMB)                    // → true
     *
     * // Works with object tiles
     * TileTypeChecker.isTileType({ type: TILE_TYPES.BOMB, justPlaced: true }, TILE_TYPES.BOMB)  // → true
     *
     * // Handles null/undefined safely
     * TileTypeChecker.isTileType(null, TILE_TYPES.FLOOR)                             // → false
     */
    static isTileType(tile: any, tileType: number): boolean {
        return TileTypeChecker.getTileType(tile) === tileType;
    }

    /**
     * Checks if a value is a valid tile (either primitive or object).
     *
     * @param tile - Value to check
     * @returns True if the value is a valid tile
     *
     * @example
     * TileTypeChecker.isValidTile(TILE_TYPES.FLOOR)           // → true
     * TileTypeChecker.isValidTile({ type: TILE_TYPES.BOMB })  // → true
     * TileTypeChecker.isValidTile(null)                       // → false
     */
    static isValidTile(tile: any): boolean {
        return TileTypeChecker.getTileType(tile) !== undefined;
    }

    // ========================================
    // SPECIFIC TILE TYPE CHECKERS (GENERATED)
    // ========================================
    static isFloor(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FLOOR);
    }

    static isWall(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.WALL);
    }

    static isGrass(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.GRASS);
    }

    static isExit(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.EXIT);
    }

    static isRock(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.ROCK);
    }

    static isHouse(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HOUSE);
    }

    static isShack(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SHACK);
    }

    static isWater(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.WATER);
    }

    static isFood(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FOOD);
    }

    static isShrubbery(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SHRUBBERY);
    }

    static isWell(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.WELL);
    }

    static isDeadTree(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.DEADTREE);
    }

    static isAxe(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.AXE);
    }

    static isHammer(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HAMMER);
    }

    static isBishopSpear(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BISHOP_SPEAR);
    }

    static isBow(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOW);
    }

    static isShovel(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SHOVEL);
    }

    static isBomb(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOMB);
    }

    static isHeart(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HEART);
    }

    static isNote(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.NOTE);
    }

    static isBookOfTimeTravel(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOOK_OF_TIME_TRAVEL);
    }

    static isFischersCube(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FISCHERS_CUBE);
    }

    static isHorseIcon(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HORSE_ICON);
    }

    static isSign(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SIGN);
    }

    static isPort(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PORT);
    }

    static isGrate(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.Grate);
    }

    static isPitfall(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PITFALL);
    }

    static isTable(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.TABLE);
    }

    static isBombStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOMB_STATUE);
    }

    static isSpearStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SPEAR_STATUE);
    }

    static isBowStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOW_STATUE);
    }

    static isHorseStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HORSE_STATUE);
    }

    static isBookStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOOK_STATUE);
    }

    static isShovelStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SHOVEL_STATUE);
    }

    // ========================================
    // CATEGORY CHECKERS
    // ========================================

    /**
     * Checks if a tile is walkable (not blocking movement).
     * Walls, rocks, houses, and shacks block movement.
     *
     * @param tile - Tile to check
     * @returns True if tile allows movement
     */
    static isWalkable(tile: any): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type !== TILE_TYPES.WALL &&
               type !== TILE_TYPES.ROCK &&
               type !== TILE_TYPES.HOUSE &&
               type !== TILE_TYPES.SHACK &&
               type !== TILE_TYPES.SIGN;
    }
    /**
     * Checks if a tile is a collectible item.
     *
     * @param tile - Tile to check
     * @returns True if tile matches the category
     */
    static isItem(tile: any): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.AXE ||
               type === TILE_TYPES.HAMMER ||
               type === TILE_TYPES.BISHOP_SPEAR ||
               type === TILE_TYPES.HORSE_ICON ||
               type === TILE_TYPES.BOMB ||
               type === TILE_TYPES.HEART ||
               type === TILE_TYPES.WATER ||
               type === TILE_TYPES.FOOD ||
               type === TILE_TYPES.NOTE ||
               type === TILE_TYPES.BOOK_OF_TIME_TRAVEL ||
               type === TILE_TYPES.BOW ||
               type === TILE_TYPES.SHOVEL;
    }

    /**
     * Checks if a tile is choppable (requires axe).
     *
     * @param tile - Tile to check
     * @returns True if tile matches the category
     */
    static isChoppable(tile: any): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.GRASS ||
               type === TILE_TYPES.SHRUBBERY;
    }

    /**
     * Checks if a tile is breakable (requires hammer).
     *
     * @param tile - Tile to check
     * @returns True if tile matches the category
     */
    static isBreakable(tile: any): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.ROCK;
    }

    // ========================================
    // OBJECT PROPERTY HELPERS
    // ========================================

    /**
     * Safely gets a property from a tile object.
     * Returns undefined if the tile is not an object or doesn't have the property.
     *
     * @param tile - Tile to check
     * @param property - Property name to retrieve
     * @returns The property value, or undefined
     *
     * @example
     * TileTypeChecker.getTileProperty({ type: TILE_TYPES.BOMB, actionsSincePlaced: 5 }, 'actionsSincePlaced')  // → 5
     * TileTypeChecker.getTileProperty(TILE_TYPES.FLOOR, 'actionsSincePlaced')                                  // → undefined
     */
    static getTileProperty(tile: any, property: string): any {
        if (TileTypeChecker.isTileObject(tile)) {
            return tile[property];
        }
        return undefined;
    }

    /**
     * Checks if a tile object has a specific property.
     *
     * @param tile - Tile to check
     * @param property - Property name to check for
     * @returns True if the tile is an object and has the property
     *
     * @example
     * TileTypeChecker.hasTileProperty({ type: TILE_TYPES.BOMB, justPlaced: true }, 'justPlaced')  // → true
     * TileTypeChecker.hasTileProperty(TILE_TYPES.FLOOR, 'justPlaced')                             // → false
     */
    static hasTileProperty(tile: any, property: string): boolean {
        return TileTypeChecker.isTileObject(tile) && property in tile;
    }

    /**
     * Checks if a tile is an object with a specific type.
     * Useful for validating before accessing object-specific properties.
     *
     * Replaces: `typeof tile === 'object' && tile !== null && tile.type === TILE_TYPES.X`
     *
     * @param tile - Tile to check
     * @param tileType - Expected TILE_TYPES value
     * @returns True if tile is an object of the specified type
     *
     * @example
     * // ❌ BAD - Verbose and repetitive
     * if (tapTile && typeof tapTile === 'object' && tapTile !== null && tapTile.type === TILE_TYPES.BOMB) {
     *     return tapTile.actionsSincePlaced;
     * }
     *
     * // ✅ GOOD - Clean and semantic
     * if (TileTypeChecker.isTileObjectOfType(tapTile, TILE_TYPES.BOMB)) {
     *     return tapTile.actionsSincePlaced;
     * }
     */
    static isTileObjectOfType(tile: any, tileType: number): boolean {
        return TileTypeChecker.isTileObject(tile) && tile.type === tileType;
    }

    /**
     * Checks if a tile object matches a type AND has a specific property value.
     *
     * @param tile - Tile to check
     * @param tileType - Expected TILE_TYPES value
     * @param property - Property name to check
     * @param expectedValue - Expected property value
     * @returns True if all conditions match
     *
     * @example
     * TileTypeChecker.isTileObjectWithProperty({ type: TILE_TYPES.BOMB, justPlaced: true }, TILE_TYPES.BOMB, 'justPlaced', true)  // → true
     */
    static isTileObjectWithProperty(tile: any, tileType: number, property: string, expectedValue: any): boolean {
        return TileTypeChecker.isTileObjectOfType(tile, tileType) && tile[property] === expectedValue;
    }
}

// ========================================
// ENTITY TYPE CHECKER CLASS
// ========================================

/**
 * EntityTypeChecker - Handles all entity-related type checking
 * Includes NPCs, enemies, and enemy statues
 */
export class EntityTypeChecker {
    // ========================================
    // SPECIFIC ENTITY TYPE CHECKERS (GENERATED)
    // ========================================
    static isPenne(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PENNE);
    }

    static isSquig(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SQUIG);
    }

    static isNib(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.NIB);
    }

    static isRune(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.RUNE);
    }

    static isCrayn(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.CRAYN);
    }

    static isFelt(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FELT);
    }

    static isForge(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FORGE);
    }

    static isMark(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.MARK);
    }

    static isAxolotl(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.AXELOTL);
    }

    static isGouge(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.GOUGE);
    }

    static isAster(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.ASTER);
    }

    static isBlot(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BLOT);
    }

    static isBlotter(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BLOTTER);
    }

    static isBrush(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BRUSH);
    }

    static isBurin(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BURIN);
    }

    static isCalamus(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.CALAMUS);
    }

    static isCap(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.CAP);
    }

    static isCinnabar(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.CINNABAR);
    }

    static isCrock(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.CROCK);
    }

    static isFilum(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FILUM);
    }

    static isFork(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FORK);
    }

    static isGel(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.GEL);
    }

    static isGouache(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.GOUACHE);
    }

    static isHane(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HANE);
    }

    static isKraft(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.KRAFT);
    }

    static isMerki(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.MERKI);
    }

    static isMicron(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.MICRON);
    }

    static isPenni(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PENNI);
    }

    static isPluma(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PLUMA);
    }

    static isPlume(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PLUME);
    }

    static isQuill(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.QUILL);
    }

    static isRaddle(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.RADDLE);
    }

    static isScritch(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SCRITCH);
    }

    static isSilver(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SILVER);
    }

    static isSine(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SINE);
    }

    static isSlate(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SLATE);
    }

    static isSlick(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SLICK);
    }

    static isSlug(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SLUG);
    }

    static isStylet(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.STYLET);
    }

    static isVellum(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.VELLUM);
    }

    static isEnemy(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.ENEMY);
    }

    static isLizardyStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LIZARDY_STATUE);
    }

    static isLizardoStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LIZARDO_STATUE);
    }

    static isLizardeauxStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LIZARDEAUX_STATUE);
    }

    static isZardStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.ZARD_STATUE);
    }

    static isLazerdStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LAZERD_STATUE);
    }

    static isLizordStatue(tile: any): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LIZORD_STATUE);
    }

    // ========================================
    // ENTITY CATEGORY CHECKERS
    // ========================================
    /**
     * Checks if a tile is an NPC.
     *
     * @param tile - Tile to check
     * @returns True if tile matches the category
     */
    static isNPC(tile: any): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.PENNE ||
               type === TILE_TYPES.SQUIG ||
               type === TILE_TYPES.NIB ||
               type === TILE_TYPES.RUNE ||
               type === TILE_TYPES.CRAYN ||
               type === TILE_TYPES.FELT ||
               type === TILE_TYPES.FORGE ||
               type === TILE_TYPES.MARK ||
               type === TILE_TYPES.AXELOTL ||
               type === TILE_TYPES.GOUGE ||
               type === TILE_TYPES.ASTER ||
               type === TILE_TYPES.BLOT ||
               type === TILE_TYPES.BLOTTER ||
               type === TILE_TYPES.BRUSH ||
               type === TILE_TYPES.BURIN ||
               type === TILE_TYPES.CALAMUS ||
               type === TILE_TYPES.CAP ||
               type === TILE_TYPES.CINNABAR ||
               type === TILE_TYPES.CROCK ||
               type === TILE_TYPES.FILUM ||
               type === TILE_TYPES.FORK ||
               type === TILE_TYPES.GEL ||
               type === TILE_TYPES.GOUACHE ||
               type === TILE_TYPES.HANE ||
               type === TILE_TYPES.KRAFT ||
               type === TILE_TYPES.MERKI ||
               type === TILE_TYPES.MICRON ||
               type === TILE_TYPES.PENNI ||
               type === TILE_TYPES.PLUMA ||
               type === TILE_TYPES.PLUME ||
               type === TILE_TYPES.QUILL ||
               type === TILE_TYPES.RADDLE ||
               type === TILE_TYPES.SCRITCH ||
               type === TILE_TYPES.SILVER ||
               type === TILE_TYPES.SINE ||
               type === TILE_TYPES.SLATE ||
               type === TILE_TYPES.SLICK ||
               type === TILE_TYPES.SLUG ||
               type === TILE_TYPES.STYLET ||
               type === TILE_TYPES.VELLUM;
    }

    /**
     * Checks if a tile is any type of enemy statue.
     *
     * @param tile - Tile to check
     * @returns True if tile matches the category
     */
    static isEnemyStatue(tile: any): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.LIZARDY_STATUE ||
               type === TILE_TYPES.LIZARDO_STATUE ||
               type === TILE_TYPES.LIZARDEAUX_STATUE ||
               type === TILE_TYPES.ZARD_STATUE ||
               type === TILE_TYPES.LAZERD_STATUE ||
               type === TILE_TYPES.LIZORD_STATUE;
    }
}

// ========================================
// COMBINED CHECKERS (for convenience)
// ========================================
/**
 * Checks if a tile is any type of statue (enemy or item).
 *
 * @param tile - Tile to check
 * @returns True if tile matches any of the types
 */
export function isStatue(tile: any): boolean {
    const type = TileTypeChecker.getTileType(tile);
    return type === TILE_TYPES.LIZARDY_STATUE ||
           type === TILE_TYPES.LIZARDO_STATUE ||
           type === TILE_TYPES.LIZARDEAUX_STATUE ||
           type === TILE_TYPES.ZARD_STATUE ||
           type === TILE_TYPES.LAZERD_STATUE ||
           type === TILE_TYPES.LIZORD_STATUE ||
           type === TILE_TYPES.BOMB_STATUE ||
           type === TILE_TYPES.SPEAR_STATUE ||
           type === TILE_TYPES.BOW_STATUE ||
           type === TILE_TYPES.HORSE_STATUE ||
           type === TILE_TYPES.BOOK_STATUE ||
           type === TILE_TYPES.SHOVEL_STATUE;
}

// ========================================
// BACKWARD COMPATIBILITY EXPORTS (GENERATED)
// ========================================
// These maintain the original function-based API while using the new class-based implementation

// Core utilities
export const getTileType = TileTypeChecker.getTileType.bind(TileTypeChecker);
export const isTileObject = TileTypeChecker.isTileObject.bind(TileTypeChecker);
export const isTileType = TileTypeChecker.isTileType.bind(TileTypeChecker);
export const isValidTile = TileTypeChecker.isValidTile.bind(TileTypeChecker);

// Tile type checkers
export const isFloor = TileTypeChecker.isFloor.bind(TileTypeChecker);
export const isWall = TileTypeChecker.isWall.bind(TileTypeChecker);
export const isGrass = TileTypeChecker.isGrass.bind(TileTypeChecker);
export const isExit = TileTypeChecker.isExit.bind(TileTypeChecker);
export const isRock = TileTypeChecker.isRock.bind(TileTypeChecker);
export const isHouse = TileTypeChecker.isHouse.bind(TileTypeChecker);
export const isShack = TileTypeChecker.isShack.bind(TileTypeChecker);
export const isWater = TileTypeChecker.isWater.bind(TileTypeChecker);
export const isFood = TileTypeChecker.isFood.bind(TileTypeChecker);
export const isShrubbery = TileTypeChecker.isShrubbery.bind(TileTypeChecker);
export const isWell = TileTypeChecker.isWell.bind(TileTypeChecker);
export const isDeadTree = TileTypeChecker.isDeadTree.bind(TileTypeChecker);
export const isAxe = TileTypeChecker.isAxe.bind(TileTypeChecker);
export const isHammer = TileTypeChecker.isHammer.bind(TileTypeChecker);
export const isBishopSpear = TileTypeChecker.isBishopSpear.bind(TileTypeChecker);
export const isBow = TileTypeChecker.isBow.bind(TileTypeChecker);
export const isShovel = TileTypeChecker.isShovel.bind(TileTypeChecker);
export const isBomb = TileTypeChecker.isBomb.bind(TileTypeChecker);
export const isHeart = TileTypeChecker.isHeart.bind(TileTypeChecker);
export const isNote = TileTypeChecker.isNote.bind(TileTypeChecker);
export const isBookOfTimeTravel = TileTypeChecker.isBookOfTimeTravel.bind(TileTypeChecker);
export const isFischersCube = TileTypeChecker.isFischersCube.bind(TileTypeChecker);
export const isHorseIcon = TileTypeChecker.isHorseIcon.bind(TileTypeChecker);
export const isSign = TileTypeChecker.isSign.bind(TileTypeChecker);
export const isPort = TileTypeChecker.isPort.bind(TileTypeChecker);
export const isGrate = TileTypeChecker.isGrate.bind(TileTypeChecker);
export const isPitfall = TileTypeChecker.isPitfall.bind(TileTypeChecker);
export const isTable = TileTypeChecker.isTable.bind(TileTypeChecker);
export const isBombStatue = TileTypeChecker.isBombStatue.bind(TileTypeChecker);
export const isSpearStatue = TileTypeChecker.isSpearStatue.bind(TileTypeChecker);
export const isBowStatue = TileTypeChecker.isBowStatue.bind(TileTypeChecker);
export const isHorseStatue = TileTypeChecker.isHorseStatue.bind(TileTypeChecker);
export const isBookStatue = TileTypeChecker.isBookStatue.bind(TileTypeChecker);
export const isShovelStatue = TileTypeChecker.isShovelStatue.bind(TileTypeChecker);

// Tile category checkers
export const isWalkable = TileTypeChecker.isWalkable.bind(TileTypeChecker);
export const isItem = TileTypeChecker.isItem.bind(TileTypeChecker);
export const isChoppable = TileTypeChecker.isChoppable.bind(TileTypeChecker);
export const isBreakable = TileTypeChecker.isBreakable.bind(TileTypeChecker);

// Tile property helpers
export const getTileProperty = TileTypeChecker.getTileProperty.bind(TileTypeChecker);
export const hasTileProperty = TileTypeChecker.hasTileProperty.bind(TileTypeChecker);
export const isTileObjectOfType = TileTypeChecker.isTileObjectOfType.bind(TileTypeChecker);
export const isTileObjectWithProperty = TileTypeChecker.isTileObjectWithProperty.bind(TileTypeChecker);

// Entity type checkers
export const isPenne = EntityTypeChecker.isPenne.bind(EntityTypeChecker);
export const isSquig = EntityTypeChecker.isSquig.bind(EntityTypeChecker);
export const isNib = EntityTypeChecker.isNib.bind(EntityTypeChecker);
export const isRune = EntityTypeChecker.isRune.bind(EntityTypeChecker);
export const isCrayn = EntityTypeChecker.isCrayn.bind(EntityTypeChecker);
export const isFelt = EntityTypeChecker.isFelt.bind(EntityTypeChecker);
export const isForge = EntityTypeChecker.isForge.bind(EntityTypeChecker);
export const isMark = EntityTypeChecker.isMark.bind(EntityTypeChecker);
export const isAxolotl = EntityTypeChecker.isAxolotl.bind(EntityTypeChecker);
export const isGouge = EntityTypeChecker.isGouge.bind(EntityTypeChecker);
export const isAster = EntityTypeChecker.isAster.bind(EntityTypeChecker);
export const isBlot = EntityTypeChecker.isBlot.bind(EntityTypeChecker);
export const isBlotter = EntityTypeChecker.isBlotter.bind(EntityTypeChecker);
export const isBrush = EntityTypeChecker.isBrush.bind(EntityTypeChecker);
export const isBurin = EntityTypeChecker.isBurin.bind(EntityTypeChecker);
export const isCalamus = EntityTypeChecker.isCalamus.bind(EntityTypeChecker);
export const isCap = EntityTypeChecker.isCap.bind(EntityTypeChecker);
export const isCinnabar = EntityTypeChecker.isCinnabar.bind(EntityTypeChecker);
export const isCrock = EntityTypeChecker.isCrock.bind(EntityTypeChecker);
export const isFilum = EntityTypeChecker.isFilum.bind(EntityTypeChecker);
export const isFork = EntityTypeChecker.isFork.bind(EntityTypeChecker);
export const isGel = EntityTypeChecker.isGel.bind(EntityTypeChecker);
export const isGouache = EntityTypeChecker.isGouache.bind(EntityTypeChecker);
export const isHane = EntityTypeChecker.isHane.bind(EntityTypeChecker);
export const isKraft = EntityTypeChecker.isKraft.bind(EntityTypeChecker);
export const isMerki = EntityTypeChecker.isMerki.bind(EntityTypeChecker);
export const isMicron = EntityTypeChecker.isMicron.bind(EntityTypeChecker);
export const isPenni = EntityTypeChecker.isPenni.bind(EntityTypeChecker);
export const isPluma = EntityTypeChecker.isPluma.bind(EntityTypeChecker);
export const isPlume = EntityTypeChecker.isPlume.bind(EntityTypeChecker);
export const isQuill = EntityTypeChecker.isQuill.bind(EntityTypeChecker);
export const isRaddle = EntityTypeChecker.isRaddle.bind(EntityTypeChecker);
export const isScritch = EntityTypeChecker.isScritch.bind(EntityTypeChecker);
export const isSilver = EntityTypeChecker.isSilver.bind(EntityTypeChecker);
export const isSine = EntityTypeChecker.isSine.bind(EntityTypeChecker);
export const isSlate = EntityTypeChecker.isSlate.bind(EntityTypeChecker);
export const isSlick = EntityTypeChecker.isSlick.bind(EntityTypeChecker);
export const isSlug = EntityTypeChecker.isSlug.bind(EntityTypeChecker);
export const isStylet = EntityTypeChecker.isStylet.bind(EntityTypeChecker);
export const isVellum = EntityTypeChecker.isVellum.bind(EntityTypeChecker);
export const isEnemy = EntityTypeChecker.isEnemy.bind(EntityTypeChecker);
export const isLizardyStatue = EntityTypeChecker.isLizardyStatue.bind(EntityTypeChecker);
export const isLizardoStatue = EntityTypeChecker.isLizardoStatue.bind(EntityTypeChecker);
export const isLizardeauxStatue = EntityTypeChecker.isLizardeauxStatue.bind(EntityTypeChecker);
export const isZardStatue = EntityTypeChecker.isZardStatue.bind(EntityTypeChecker);
export const isLazerdStatue = EntityTypeChecker.isLazerdStatue.bind(EntityTypeChecker);
export const isLizordStatue = EntityTypeChecker.isLizordStatue.bind(EntityTypeChecker);

// Entity category checkers
export const isNPC = EntityTypeChecker.isNPC.bind(EntityTypeChecker);
export const isEnemyStatue = EntityTypeChecker.isEnemyStatue.bind(EntityTypeChecker);

// ========================================
// MIGRATION ALIASES
// ========================================
// For backward compatibility during refactoring

/**
 * @deprecated Use isTileType() instead
 * Alias maintained for backward compatibility during migration
 */
export function checkTileType(tile: any, tileType: number): boolean {
    return TileTypeChecker.isTileType(tile, tileType);
}

/**
 * @deprecated Use isTileObject() instead
 * Alias maintained for backward compatibility during migration
 */
export function isTileObj(tile: any): boolean {
    return TileTypeChecker.isTileObject(tile);
}
