/**
 * TypeChecks - Standardized type checking utilities for the Chesse codebase
 *
 * ⚠️  THIS FILE IS AUTO-GENERATED - DO NOT EDIT DIRECTLY
 * Generated by: utils/generateTypeChecks.js
 * To modify: Edit the configuration in generateTypeChecks.js and regenerate
 *
 * PROBLEM SOLVED:
 * This module eliminates inconsistent type checking patterns throughout the codebase.
 *
 * RECOMMENDED USAGE:
 * ✅ GOOD: TileTypeChecker.isBomb(tile), TileTypeChecker.isTileObject(tile)
 * ✅ GOOD: EntityTypeChecker.isPenne(tile), EntityTypeChecker.isNPC(tile)
 * ❌ BAD:  typeof tile === 'object' && tile !== null && tile.type === TILE_TYPES.BOMB
 * ❌ BAD:  tile === TILE_TYPES.BOMB (when tile could be an object)
 */

import { TILE_TYPES, TileType } from '@core/constants/index';

/**
 * A tile can be either a primitive number (tile type) or an object with a type property
 */
export type Tile = number | {
    type: number;
    uses?: number;
    message?: string;
    foodType?: string;
    name?: string;
    icon?: string;
    npcType?: string;
    enemyType?: string;
    direction?: string;
    discovered?: boolean;
    actionsSincePlaced?: number;
    justPlaced?: boolean;
} | null | undefined;

// ========================================
// TILE TYPE CHECKER CLASS
// ========================================

/**
 * TileTypeChecker - Handles all tile-related type checking
 * Includes terrain, items, structures, and interactive objects
 */
export class TileTypeChecker {
    // ========================================
    // CORE TYPE UTILITIES
    // ========================================

    /**
     * Normalizes a tile to its type value.
     * Handles both primitive tile types (numbers) and tile objects.
     */
    static getTileType(tile: Tile): number | undefined {
        if (tile === null || tile === undefined) {
            return undefined;
        }

        if (typeof tile === 'object') {
            return tile.type;
        }

        return tile;
    }

    /**
     * Checks if a tile is a valid tile object (not just a primitive type).
     * Type guard for tile objects.
     */
    static isTileObject(tile: unknown): tile is { type: number; [key: string]: unknown } {
        return tile !== null && typeof tile === 'object' && 'type' in tile && (tile as { type: unknown }).type !== undefined;
    }

    /**
     * Checks if a tile has the specified type.
     * Handles both primitive tiles and tile objects seamlessly.
     */
    static isTileType(tile: Tile, tileType: number): boolean {
        return TileTypeChecker.getTileType(tile) === tileType;
    }

    /**
     * Checks if a value is a valid tile (either primitive or object).
     */
    static isValidTile(tile: unknown): tile is Tile {
        return TileTypeChecker.getTileType(tile as Tile) !== undefined;
    }

    // ========================================
    // SPECIFIC TILE TYPE CHECKERS (GENERATED)
    // ========================================
    static isFloor(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FLOOR);
    }

    static isWall(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.WALL);
    }

    static isGrass(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.GRASS);
    }

    static isExit(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.EXIT);
    }

    static isRock(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.ROCK);
    }

    static isHouse(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HOUSE);
    }

    static isShack(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SHACK);
    }

    static isWater(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.WATER);
    }

    static isFood(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FOOD);
    }

    static isShrubbery(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SHRUBBERY);
    }

    static isWell(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.WELL);
    }

    static isDeadTree(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.DEADTREE);
    }

    static isAxe(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.AXE);
    }

    static isHammer(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HAMMER);
    }

    static isBishopSpear(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BISHOP_SPEAR);
    }

    static isBow(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOW);
    }

    static isShovel(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SHOVEL);
    }

    static isBomb(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOMB);
    }

    static isHeart(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HEART);
    }

    static isNote(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.NOTE);
    }

    static isBookOfTimeTravel(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOOK_OF_TIME_TRAVEL);
    }

    static isHorseIcon(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HORSE_ICON);
    }

    static isSign(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SIGN);
    }

    static isPort(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PORT);
    }

    static isCistern(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.CISTERN);
    }

    static isPitfall(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PITFALL);
    }

    static isTable(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.TABLE);
    }

    static isBombStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOMB_STATUE);
    }

    static isSpearStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SPEAR_STATUE);
    }

    static isBowStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOW_STATUE);
    }

    static isHorseStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.HORSE_STATUE);
    }

    static isBookStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.BOOK_STATUE);
    }

    static isShovelStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SHOVEL_STATUE);
    }

    static isFischersCube(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FISCHERS_CUBE);
    }

    static isTeleportBranch(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.TELEPORT_BRANCH);
    }

    // ========================================
    // CATEGORY CHECKERS
    // ========================================

    /**
     * Checks if a tile is walkable (not blocking movement).
     */
    static isWalkable(tile: Tile): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type !== TILE_TYPES.WALL &&
               type !== TILE_TYPES.ROCK &&
               type !== TILE_TYPES.HOUSE &&
               type !== TILE_TYPES.SHACK &&
               type !== TILE_TYPES.SIGN;
    }

    /**
     * Checks if a tile is a collectible item.
     */
    static isItem(tile: Tile): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.AXE ||
               type === TILE_TYPES.HAMMER ||
               type === TILE_TYPES.BISHOP_SPEAR ||
               type === TILE_TYPES.HORSE_ICON ||
               type === TILE_TYPES.BOMB ||
               type === TILE_TYPES.HEART ||
               type === TILE_TYPES.WATER ||
               type === TILE_TYPES.FOOD ||
               type === TILE_TYPES.NOTE ||
               type === TILE_TYPES.BOOK_OF_TIME_TRAVEL ||
               type === TILE_TYPES.BOW ||
               type === TILE_TYPES.SHOVEL ||
               type === TILE_TYPES.FISCHERS_CUBE ||
               type === TILE_TYPES.TELEPORT_BRANCH ||
               type === TILE_TYPES.FISCHERS_WAND;
    }

    /**
     * Checks if a tile is choppable (requires axe).
     */
    static isChoppable(tile: Tile): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.GRASS ||
               type === TILE_TYPES.SHRUBBERY;
    }

    /**
     * Checks if a tile is breakable (requires hammer).
     */
    static isBreakable(tile: Tile): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.ROCK;
    }

    // ========================================
    // OBJECT PROPERTY HELPERS
    // ========================================

    /**
     * Safely gets a property from a tile object.
     */
    static getTileProperty<K extends string>(tile: Tile, property: K): unknown {
        if (TileTypeChecker.isTileObject(tile)) {
            return tile[property];
        }
        return undefined;
    }

    /**
     * Checks if a tile object has a specific property.
     */
    static hasTileProperty(tile: Tile, property: string): boolean {
        return TileTypeChecker.isTileObject(tile) && property in tile;
    }

    /**
     * Checks if a tile is an object with a specific type.
     * Type guard that narrows to tile object.
     */
    static isTileObjectOfType(tile: unknown, tileType: number): tile is { type: number; [key: string]: unknown } {
        return TileTypeChecker.isTileObject(tile) && (tile as { type: number }).type === tileType;
    }

    /**
     * Checks if a tile object matches a type AND has a specific property value.
     */
    static isTileObjectWithProperty(tile: unknown, tileType: number, property: string, expectedValue: unknown): boolean {
        return TileTypeChecker.isTileObjectOfType(tile, tileType) &&
            (tile as Record<string, unknown>)[property] === expectedValue;
    }
}

// ========================================
// ENTITY TYPE CHECKER CLASS
// ========================================

/**
 * EntityTypeChecker - Handles all entity-related type checking
 * Includes NPCs, enemies, and enemy statues
 */
export class EntityTypeChecker {
    static isPenne(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.PENNE);
    }

    static isSquig(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.SQUIG);
    }

    static isNib(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.NIB);
    }

    static isRune(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.RUNE);
    }

    static isCrayn(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.CRAYN);
    }

    static isFelt(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FELT);
    }

    static isForge(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.FORGE);
    }

    static isMark(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.MARK);
    }

    static isAxolotl(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.AXELOTL);
    }

    static isGouge(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.GOUGE);
    }

    static isEnemy(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.ENEMY);
    }

    static isLizardyStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LIZARDY_STATUE);
    }

    static isLizardoStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LIZARDO_STATUE);
    }

    static isLizardeauxStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LIZARDEAUX_STATUE);
    }

    static isZardStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.ZARD_STATUE);
    }

    static isLazerdStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LAZERD_STATUE);
    }

    static isLizordStatue(tile: Tile): boolean {
        return TileTypeChecker.isTileType(tile, TILE_TYPES.LIZORD_STATUE);
    }

    /**
     * Checks if a tile is an NPC.
     */
    static isNPC(tile: Tile): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.PENNE ||
               type === TILE_TYPES.SQUIG ||
               type === TILE_TYPES.NIB ||
               type === TILE_TYPES.RUNE ||
               type === TILE_TYPES.CRAYN ||
               type === TILE_TYPES.FELT ||
               type === TILE_TYPES.FORGE ||
               type === TILE_TYPES.MARK ||
               type === TILE_TYPES.AXELOTL ||
               type === TILE_TYPES.GOUGE;
    }

    /**
     * Checks if a tile is any type of enemy statue.
     */
    static isEnemyStatue(tile: Tile): boolean {
        const type = TileTypeChecker.getTileType(tile);
        return type === TILE_TYPES.LIZARDY_STATUE ||
               type === TILE_TYPES.LIZARDO_STATUE ||
               type === TILE_TYPES.LIZARDEAUX_STATUE ||
               type === TILE_TYPES.ZARD_STATUE ||
               type === TILE_TYPES.LAZERD_STATUE ||
               type === TILE_TYPES.LIZORD_STATUE;
    }
}

// ========================================
// COMBINED CHECKERS
// ========================================

/**
 * Checks if a tile is any type of statue (enemy or item).
 */
export function isStatue(tile: Tile): boolean {
    const type = TileTypeChecker.getTileType(tile);
    return type === TILE_TYPES.LIZARDY_STATUE ||
           type === TILE_TYPES.LIZARDO_STATUE ||
           type === TILE_TYPES.LIZARDEAUX_STATUE ||
           type === TILE_TYPES.ZARD_STATUE ||
           type === TILE_TYPES.LAZERD_STATUE ||
           type === TILE_TYPES.LIZORD_STATUE ||
           type === TILE_TYPES.BOMB_STATUE ||
           type === TILE_TYPES.SPEAR_STATUE ||
           type === TILE_TYPES.BOW_STATUE ||
           type === TILE_TYPES.HORSE_STATUE ||
           type === TILE_TYPES.BOOK_STATUE ||
           type === TILE_TYPES.SHOVEL_STATUE;
}

// ========================================
// BACKWARD COMPATIBILITY EXPORTS
// ========================================

// Core utilities
export const getTileType = (tile: Tile) => TileTypeChecker.getTileType(tile);
export const isTileObject = (tile: unknown) => TileTypeChecker.isTileObject(tile);
export const isTileType = (tile: Tile, tileType: number) => TileTypeChecker.isTileType(tile, tileType);
export const isValidTile = (tile: unknown) => TileTypeChecker.isValidTile(tile);

// Tile type checkers
export const isFloor = (tile: Tile) => TileTypeChecker.isFloor(tile);
export const isWall = (tile: Tile) => TileTypeChecker.isWall(tile);
export const isGrass = (tile: Tile) => TileTypeChecker.isGrass(tile);
export const isExit = (tile: Tile) => TileTypeChecker.isExit(tile);
export const isRock = (tile: Tile) => TileTypeChecker.isRock(tile);
export const isHouse = (tile: Tile) => TileTypeChecker.isHouse(tile);
export const isShack = (tile: Tile) => TileTypeChecker.isShack(tile);
export const isWater = (tile: Tile) => TileTypeChecker.isWater(tile);
export const isFood = (tile: Tile) => TileTypeChecker.isFood(tile);
export const isShrubbery = (tile: Tile) => TileTypeChecker.isShrubbery(tile);
export const isWell = (tile: Tile) => TileTypeChecker.isWell(tile);
export const isDeadTree = (tile: Tile) => TileTypeChecker.isDeadTree(tile);
export const isAxe = (tile: Tile) => TileTypeChecker.isAxe(tile);
export const isHammer = (tile: Tile) => TileTypeChecker.isHammer(tile);
export const isBishopSpear = (tile: Tile) => TileTypeChecker.isBishopSpear(tile);
export const isBow = (tile: Tile) => TileTypeChecker.isBow(tile);
export const isShovel = (tile: Tile) => TileTypeChecker.isShovel(tile);
export const isBomb = (tile: Tile) => TileTypeChecker.isBomb(tile);
export const isHeart = (tile: Tile) => TileTypeChecker.isHeart(tile);
export const isNote = (tile: Tile) => TileTypeChecker.isNote(tile);
export const isBookOfTimeTravel = (tile: Tile) => TileTypeChecker.isBookOfTimeTravel(tile);
export const isHorseIcon = (tile: Tile) => TileTypeChecker.isHorseIcon(tile);
export const isSign = (tile: Tile) => TileTypeChecker.isSign(tile);
export const isPort = (tile: Tile) => TileTypeChecker.isPort(tile);
export const isCistern = (tile: Tile) => TileTypeChecker.isCistern(tile);
export const isPitfall = (tile: Tile) => TileTypeChecker.isPitfall(tile);
export const isTable = (tile: Tile) => TileTypeChecker.isTable(tile);
export const isBombStatue = (tile: Tile) => TileTypeChecker.isBombStatue(tile);
export const isSpearStatue = (tile: Tile) => TileTypeChecker.isSpearStatue(tile);
export const isBowStatue = (tile: Tile) => TileTypeChecker.isBowStatue(tile);
export const isHorseStatue = (tile: Tile) => TileTypeChecker.isHorseStatue(tile);
export const isBookStatue = (tile: Tile) => TileTypeChecker.isBookStatue(tile);
export const isShovelStatue = (tile: Tile) => TileTypeChecker.isShovelStatue(tile);
export const isFischersCube = (tile: Tile) => TileTypeChecker.isFischersCube(tile);
export const isTeleportBranch = (tile: Tile) => TileTypeChecker.isTeleportBranch(tile);

// Tile category checkers
export const isWalkable = (tile: Tile) => TileTypeChecker.isWalkable(tile);
export const isItem = (tile: Tile) => TileTypeChecker.isItem(tile);
export const isChoppable = (tile: Tile) => TileTypeChecker.isChoppable(tile);
export const isBreakable = (tile: Tile) => TileTypeChecker.isBreakable(tile);

// Tile property helpers
export const getTileProperty = (tile: Tile, property: string) => TileTypeChecker.getTileProperty(tile, property);
export const hasTileProperty = (tile: Tile, property: string) => TileTypeChecker.hasTileProperty(tile, property);
export const isTileObjectOfType = (tile: unknown, tileType: number) => TileTypeChecker.isTileObjectOfType(tile, tileType);
export const isTileObjectWithProperty = (tile: unknown, tileType: number, property: string, expectedValue: unknown) => TileTypeChecker.isTileObjectWithProperty(tile, tileType, property, expectedValue);

// Entity type checkers
export const isPenne = (tile: Tile) => EntityTypeChecker.isPenne(tile);
export const isSquig = (tile: Tile) => EntityTypeChecker.isSquig(tile);
export const isNib = (tile: Tile) => EntityTypeChecker.isNib(tile);
export const isRune = (tile: Tile) => EntityTypeChecker.isRune(tile);
export const isCrayn = (tile: Tile) => EntityTypeChecker.isCrayn(tile);
export const isFelt = (tile: Tile) => EntityTypeChecker.isFelt(tile);
export const isForge = (tile: Tile) => EntityTypeChecker.isForge(tile);
export const isMark = (tile: Tile) => EntityTypeChecker.isMark(tile);
export const isAxolotl = (tile: Tile) => EntityTypeChecker.isAxolotl(tile);
export const isGouge = (tile: Tile) => EntityTypeChecker.isGouge(tile);
export const isEnemy = (tile: Tile) => EntityTypeChecker.isEnemy(tile);
export const isLizardyStatue = (tile: Tile) => EntityTypeChecker.isLizardyStatue(tile);
export const isLizardoStatue = (tile: Tile) => EntityTypeChecker.isLizardoStatue(tile);
export const isLizardeauxStatue = (tile: Tile) => EntityTypeChecker.isLizardeauxStatue(tile);
export const isZardStatue = (tile: Tile) => EntityTypeChecker.isZardStatue(tile);
export const isLazerdStatue = (tile: Tile) => EntityTypeChecker.isLazerdStatue(tile);
export const isLizordStatue = (tile: Tile) => EntityTypeChecker.isLizordStatue(tile);

// Entity category checkers
export const isNPC = (tile: Tile) => EntityTypeChecker.isNPC(tile);
export const isEnemyStatue = (tile: Tile) => EntityTypeChecker.isEnemyStatue(tile);

// ========================================
// MIGRATION ALIASES
// ========================================

/** @deprecated Use isTileType() instead */
export function checkTileType(tile: Tile, tileType: number): boolean {
    return TileTypeChecker.isTileType(tile, tileType);
}

/** @deprecated Use isTileObject() instead */
export function isTileObj(tile: unknown): tile is { type: number; [key: string]: unknown } {
    return TileTypeChecker.isTileObject(tile);
}
