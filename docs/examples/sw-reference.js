/**
 * Chress Service Worker - REFERENCE IMPLEMENTATION
 *
 * NOTE: This is a reference implementation for documentation purposes.
 * The actual service worker is auto-generated by Vite PWA plugin during build
 * and placed in dist/sw.js with Workbox integration.
 *
 * This file shows the caching strategies and offline support logic.
 * The Vite PWA plugin handles this automatically via vite.config.js
 *
 * Provides offline support, asset caching, and performance optimization
 */

const CACHE_VERSION = 'chress-v1.0.1';
const CACHE_NAME = `${CACHE_VERSION}-static`;
const RUNTIME_CACHE = `${CACHE_VERSION}-runtime`;
const IMAGE_CACHE = `${CACHE_VERSION}-images`;

// Determine the base path from the service worker location
const BASE_PATH = self.location.pathname.replace(/sw\.js$/, '');

// Assets to cache immediately on install
// Empty array to avoid installation failures during development
// In production, Vite PWA will generate this list automatically
const PRECACHE_ASSETS = [];

// Assets that should always be fetched from network first
const NETWORK_FIRST_PATTERNS = [
    /\/api\//,
    /\.json$/,
    /\/data\//
];

// Assets that can be served from cache first
const CACHE_FIRST_PATTERNS = [
    /\.png$/,
    /\.jpg$/,
    /\.jpeg$/,
    /\.gif$/,
    /\.webp$/,
    /\.svg$/,
    /\.woff$/,
    /\.woff2$/,
    /\.ttf$/,
    /\.otf$/
];

/**
 * Install event - cache critical assets
 */
self.addEventListener('install', (event) => {
    console.log('[SW] Installing service worker...');
    console.log('[SW] Base path:', BASE_PATH);

    event.waitUntil(
        Promise.resolve()
            .then(() => {
                console.log('[SW] Service worker installed successfully');
                // Force activation immediately
                return self.skipWaiting();
            })
    );
});

/**
 * Activate event - clean up old caches
 */
self.addEventListener('activate', (event) => {
    console.log('[SW] Activating service worker...');

    event.waitUntil(
        caches.keys()
            .then((cacheNames) => {
                return Promise.all(
                    cacheNames.map((cacheName) => {
                        if (cacheName.startsWith('chress-') && cacheName !== CACHE_NAME &&
                            cacheName !== RUNTIME_CACHE && cacheName !== IMAGE_CACHE) {
                            console.log('[SW] Deleting old cache:', cacheName);
                            return caches.delete(cacheName);
                        }
                    })
                );
            })
            .then(() => {
                console.log('[SW] Service worker activated');
                // Take control of all pages immediately
                return self.clients.claim();
            })
    );
});

/**
 * Fetch event - implement caching strategies
 */
self.addEventListener('fetch', (event) => {
    const { request } = event;
    const url = new URL(request.url);

    // Skip non-GET requests
    if (request.method !== 'GET') {
        return;
    }

    // Skip chrome extensions and other protocols
    if (!url.protocol.startsWith('http')) {
        return;
    }

    // Determine caching strategy based on request
    if (shouldUseNetworkFirst(url)) {
        event.respondWith(networkFirst(request));
    } else if (shouldUseCacheFirst(url)) {
        event.respondWith(cacheFirst(request));
    } else {
        event.respondWith(staleWhileRevalidate(request));
    }
});

/**
 * Check if request should use network-first strategy
 */
function shouldUseNetworkFirst(url) {
    return NETWORK_FIRST_PATTERNS.some(pattern => pattern.test(url.pathname));
}

/**
 * Check if request should use cache-first strategy
 */
function shouldUseCacheFirst(url) {
    return CACHE_FIRST_PATTERNS.some(pattern => pattern.test(url.pathname));
}

/**
 * Network-first strategy: Try network, fallback to cache
 * Good for dynamic content that needs to be fresh
 */
async function networkFirst(request) {
    try {
        const response = await fetch(request);

        if (response.ok) {
            const cache = await caches.open(RUNTIME_CACHE);
            cache.put(request, response.clone());
        }

        return response;
    } catch (error) {
        const cached = await caches.match(request);

        if (cached) {
            console.log('[SW] Network failed, serving from cache:', request.url);
            return cached;
        }

        // Return offline page for navigation requests
        if (request.mode === 'navigate') {
            return createOfflineResponse();
        }

        throw error;
    }
}

/**
 * Cache-first strategy: Serve from cache, update in background
 * Good for static assets that rarely change
 */
async function cacheFirst(request) {
    const cached = await caches.match(request);

    if (cached) {
        return cached;
    }

    try {
        const response = await fetch(request);

        if (response.ok) {
            const cacheName = isImageRequest(request) ? IMAGE_CACHE : RUNTIME_CACHE;
            const cache = await caches.open(cacheName);
            cache.put(request, response.clone());
        }

        return response;
    } catch (error) {
        console.error('[SW] Cache-first fetch failed:', request.url, error);
        throw error;
    }
}

/**
 * Stale-while-revalidate strategy: Serve from cache, update in background
 * Good for assets that can be slightly stale
 */
async function staleWhileRevalidate(request) {
    const cached = await caches.match(request);

    const fetchPromise = fetch(request).then((response) => {
        if (response.ok) {
            const cache = caches.open(RUNTIME_CACHE);
            cache.then(c => c.put(request, response.clone()));
        }
        return response;
    }).catch(() => {
        // Network failed, return cached if available
        return cached;
    });

    return cached || fetchPromise;
}

/**
 * Check if request is for an image
 */
function isImageRequest(request) {
    return request.destination === 'image' ||
           /\.(png|jpg|jpeg|gif|webp|svg)$/i.test(new URL(request.url).pathname);
}

/**
 * Create offline response for navigation requests
 */
function createOfflineResponse() {
    const html = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Chress - Offline</title>
            <style>
                body {
                    font-family: 'Courier New', monospace;
                    background: linear-gradient(180deg, #2d1b3d 0%, #3e2347 40%, #4a2d52 100%);
                    color: #ffffeb;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 100vh;
                    margin: 0;
                    text-align: center;
                }
                .offline-container {
                    padding: 40px;
                    background: rgba(255, 255, 255, 0.1);
                    border-radius: 12px;
                    backdrop-filter: blur(10px);
                }
                h1 { margin-bottom: 20px; }
                button {
                    margin-top: 20px;
                    padding: 12px 24px;
                    background: #606070;
                    color: #ffffeb;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 16px;
                }
                button:hover { background: #7e7e8f; }
            </style>
        </head>
        <body>
            <div class="offline-container">
                <h1>You're Offline</h1>
                <p>Chress requires an internet connection to load new content.</p>
                <p>Your game progress is saved locally.</p>
                <button onclick="window.location.reload()">Retry</button>
            </div>
        </body>
        </html>
    `;

    return new Response(html, {
        headers: { 'Content-Type': 'text/html' }
    });
}

/**
 * Handle messages from the main thread
 */
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }

    if (event.data && event.data.type === 'CACHE_URLS') {
        const { urls } = event.data;
        caches.open(RUNTIME_CACHE).then(cache => {
            cache.addAll(urls);
        });
    }

    if (event.data && event.data.type === 'CLEAR_CACHE') {
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.map(cacheName => {
                    if (cacheName.startsWith('chress-')) {
                        return caches.delete(cacheName);
                    }
                })
            );
        }).then(() => {
            self.clients.matchAll().then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'CACHE_CLEARED' });
                });
            });
        });
    }
});

/**
 * Background sync for saving game state
 */
self.addEventListener('sync', (event) => {
    if (event.tag === 'sync-game-state') {
        event.waitUntil(syncGameState());
    }
});

/**
 * Sync game state (placeholder for future implementation)
 */
async function syncGameState() {
    console.log('[SW] Syncing game state...');
    // Future: Implement cloud save sync here
    return Promise.resolve();
}

console.log('[SW] Service worker loaded');
