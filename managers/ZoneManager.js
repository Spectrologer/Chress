import { GRID_SIZE, TILE_TYPES } from '../core/constants/index.js';
import { Sign } from '../ui/Sign.js';
import { logger } from '../core/logger.js';
import { createZoneKey } from '../utils/ZoneKeyUtils.js';
import { eventBus } from '../core/EventBus.js';
import { EventTypes } from '../core/EventTypes.js';
import { isWithinGrid } from '../utils/GridUtils.js';
import { isFloor, isTileType } from '../utils/TileUtils.js';

export class ZoneManager {
    constructor(game) {
        this.game = game;
    }

    transitionToZone(newZoneX, newZoneY, exitSide, exitX, exitY) {
        // Set flag to skip enemy movements this turn since player just entered zone
        this.game.lastExitSide = exitSide; // Store how we entered for generation logic

        // Reset sign message tracking for the new zone
        this.game.lastSignMessage = null;
        this.game.displayingMessageForSign = null;

        // Set pitfall zone flag based on transition data
        this.game.isInPitfallZone = this.game.portTransitionData?.from === 'pitfall';
        if (exitSide !== 'port') {
            this.game.pitfallTurnsSurvived = 0; // Reset on any non-port transition
            this.game.isInPitfallZone = false; // Clear flag if not a port transition
        }

        // Check if this is a special zone marked by a note
        const zoneKey = `${newZoneX},${newZoneY}`;
        const hasReachedSpecialZone = this.game.specialZones.has(zoneKey);

        // If entering a pitfall zone, reset the turn counter
        if (this.game.isInPitfallZone) {
            this.game.pitfallTurnsSurvived = 0;
        }

        // Update player's current zone (keep dimension)
        this.game.player.setCurrentZone(newZoneX, newZoneY);

        // Note: Region notification will be handled by the UI via ZONE_CHANGED event
        // The UI will determine if it's a new region and show notification accordingly

        // Decrease thirst and hunger when moving to a new zone, unless using a port
        if (exitSide !== 'port') {
            this.game.player.onZoneTransition();
        }

        // Generate or load the new zone
        this.game.generateZone();

    try { logger && logger.debug && logger.debug(`Transition complete: lastExitSide=${exitSide}, portTransitionData=${JSON.stringify(this.game.portTransitionData)}`); } catch (e) {}

        // Position player based on which exit they used
        this.positionPlayerAfterTransition(exitSide, exitX, exitY);

        // If player spawned on shrubbery, remove it (restore exit)
        const playerPos = this.game.player.getPosition();
        if (isTileType(this.game.grid[playerPos.y][playerPos.x], TILE_TYPES.SHRUBBERY)) {
            this.game.grid[playerPos.y][playerPos.x] = TILE_TYPES.EXIT;
        }

        // Ensure player is on a walkable tile
        this.game.player.ensureValidPosition(this.game.grid);

        // Prevent cross-zone interpolation: reset last position to current so renderer doesn't
        // interpolate from previous zone coordinates (which may be off-screen).
        if (this.game.player) {
            this.game.player.lastX = this.game.player.x;
            this.game.player.lastY = this.game.player.y;
        }

        // Check for special zone treasures
        if (hasReachedSpecialZone) {
            const treasures = this.game.specialZones.get(zoneKey);
            this.game.spawnTreasuresOnGrid(treasures);

            // Remove the special zone marker since it was used
            this.game.specialZones.delete(zoneKey);
        }

        // Emit zone changed event instead of calling UI/Sound managers directly
        const dimension = this.game.player.currentZone && typeof this.game.player.currentZone.dimension === 'number'
            ? this.game.player.currentZone.dimension
            : 0;

        eventBus.emit(EventTypes.ZONE_CHANGED, {
            x: newZoneX,
            y: newZoneY,
            dimension
            // regionName will be generated by UI event handler
        });

        // Emit player moved event
        eventBus.emit(EventTypes.PLAYER_MOVED, {
            x: this.game.player.x,
            y: this.game.player.y
        });

        // Save game state after zone transition
        this.game.gameStateManager.saveGameState();

        // Now that the transition is complete, clear the one-time transition data
    try { logger && logger.debug && logger.debug(`Clearing portTransitionData (was=${JSON.stringify(this.game.portTransitionData)})`); } catch (e) {}
    this.game.portTransitionData = null;
    }

    positionPlayerAfterTransition(exitSide, exitX, exitY) {
        switch (exitSide) {
            case 'bottom':
                // Came from bottom, enter north side at corresponding x position
                this.game.grid[0][exitX] = TILE_TYPES.EXIT;
                this.game.zoneGenerator.clearPathToExit(exitX, 0);
                this.game.player.setPosition(exitX, 0);
                break;
            case 'top':
                // Came from top, enter south side at corresponding x position
                this.game.grid[GRID_SIZE - 1][exitX] = TILE_TYPES.EXIT;
                this.game.zoneGenerator.clearPathToExit(exitX, GRID_SIZE - 1);
                this.game.player.setPosition(exitX, GRID_SIZE - 1);
                break;
            case 'right':
                // Came from right, enter west side at corresponding y position
                this.game.grid[exitY][0] = TILE_TYPES.EXIT;
                this.game.zoneGenerator.clearPathToExit(0, exitY);
                this.game.player.setPosition(0, exitY);
                break;
            case 'left':
                // Came from left, enter east side at corresponding y position
                this.game.grid[exitY][GRID_SIZE - 1] = TILE_TYPES.EXIT;
                this.game.zoneGenerator.clearPathToExit(GRID_SIZE - 1, exitY);
                this.game.player.setPosition(GRID_SIZE - 1, exitY);
                break;
            case 'teleport':
                // Teleport: place in center
                this.game.player.setPosition(Math.floor(GRID_SIZE / 2), Math.floor(GRID_SIZE / 2));
                break;
            case 'port':
                // For pitfalls, the player spawns at a random valid location, not on the entrance.
                // The zoneData contains the correct spawn point.
                const portZoneKey = createZoneKey(
                    this.game.player.currentZone.x,
                    this.game.player.currentZone.y,
                    this.game.player.currentZone.dimension,
                    this.game.player.currentZone.depth || (this.game.player.undergroundDepth || 1)
                );
                const zoneData = this.game.zoneRepository.getByKey(portZoneKey);

                if (this.game.portTransitionData?.from === 'pitfall') {
                    // Entering underground via pitfall: Use the zone's designated spawn point
                    // if available, otherwise fall back to the provided exit coords.
                    if (zoneData && zoneData.playerSpawn) {
                        this.game.player.setPosition(zoneData.playerSpawn.x, zoneData.playerSpawn.y);
                    } else {
                        this.game.player.setPosition(exitX, exitY);
                        this.validateAndSetTile(this.game.grid, exitX, exitY, TILE_TYPES.PORT);
                    }
                } else if (this.game.player.currentZone.dimension === 1) { // Entering an interior
                    // Entering an interior: place player at bottom-middle of interior (consistent spawn)
                    const portX = Math.floor(GRID_SIZE / 2);
                    const portY = GRID_SIZE - 1; // bottom edge
                    this.validateAndSetTile(this.game.grid, portX, portY, TILE_TYPES.PORT);
                    this.game.player.setPosition(portX, portY);
                } else if (this.game.player.currentZone.dimension === 0 && this.game.player.currentZone.portType === 'underground') {
                    // Exiting to the surface FROM underground.
                    // Prefer an explicit recorded returnToSurface (from the underground zone data) or
                    // the original portTransitionData coordinates (the hole/cistern the player fell through)
                    // before falling back to the exitX/exitY coordinates (which are the underground port coords).
                    let portX = exitX;
                    let portY = exitY;

                    try {
                        const undergroundDepth = this.game.player.currentZone.depth || (this.game.player.undergroundDepth || 1);
                        const undergroundZoneKey = createZoneKey(this.game.player.currentZone.x, this.game.player.currentZone.y, 2, undergroundDepth);
                        const undergroundData = this.game.zoneRepository.getByKey(undergroundZoneKey);
                        if (undergroundData && undergroundData.returnToSurface) {
                            portX = undergroundData.returnToSurface.x;
                            portY = undergroundData.returnToSurface.y;
                        } else if (this.game.portTransitionData && (this.game.portTransitionData.from === 'hole' || this.game.portTransitionData.from === 'pitfall')) {
                            portX = this.game.portTransitionData.x;
                            portY = this.game.portTransitionData.y;
                        }
                    } catch (e) {
                        // Non-fatal, fall back to exitX/exitY
                    }

                    this.validateAndSetTile(this.game.grid, portX, portY, TILE_TYPES.PORT);
                    this.game.player.setPosition(portX, portY);
                } else if (this.game.player.currentZone.dimension === 0) {
                    // Exiting to the surface. Prefer the interior's recorded return coordinates if available.
                    const interiorZoneKey = createZoneKey(this.game.player.currentZone.x, this.game.player.currentZone.y, 1);
                    const interiorZoneData = this.game.zoneRepository.getByKey(interiorZoneKey);
                    let placed = false;

                    if (interiorZoneData && interiorZoneData.returnToSurface) {
                        const sx = interiorZoneData.returnToSurface.x;
                        const sy = interiorZoneData.returnToSurface.y;
                        if (sx !== undefined && sy !== undefined) {
                            this.game.player.setPosition(sx, sy);
                            this.validateAndSetTile(this.game.grid, sx, sy, TILE_TYPES.PORT);
                            placed = true;
                        }
                    }

                    if (!placed) {
                        // If the explicit exit coords are a PORT in the new grid, use them
                        if (isWithinGrid(exitX, exitY) && isTileType(this.game.grid[exitY][exitX], TILE_TYPES.PORT)) {
                            this.game.player.setPosition(exitX, exitY);
                            placed = true;
                        }
                    }

                    if (!placed) {
                        // Search the grid for any PORT tile and use the first found
                        for (let y = 0; y < GRID_SIZE && !placed; y++) {
                            for (let x = 0; x < GRID_SIZE; x++) {
                                if (isTileType(this.game.grid[y][x], TILE_TYPES.PORT)) {
                                    this.game.player.setPosition(x, y);
                                    placed = true;
                                    break;
                                }
                            }
                        }
                    }

                    if (!placed) {
                        // Fallback to using exitX/exitY
                        this.game.player.setPosition(exitX, exitY);
                        this.validateAndSetTile(this.game.grid, exitX, exitY, TILE_TYPES.PORT);
                    }
                } else {
                    // For regular ports (cisterns, holes, doors), spawn at the entrance.
                    // exitX and exitY are the coordinates of the port used in the previous zone.
                    this.game.player.setPosition(exitX, exitY);
                    this.validateAndSetTile(this.game.grid, exitX, exitY, TILE_TYPES.PORT);
                }
                break;
            default:
                // Fallback to center
                this.game.player.setPosition(Math.floor(GRID_SIZE / 2), Math.floor(GRID_SIZE / 2));
                break;
        }
    }

    /**
     * Helper to safely set a tile on the grid, checking bounds.
     * @param {Array<Array<any>>} grid The game grid.
     * @param {number} x The x-coordinate.
     * @param {number} y The y-coordinate.
     * @param {any} tile The tile to set.
     */
    validateAndSetTile(grid, x, y, tile) {
        if (isWithinGrid(x, y)) {
            // If we're trying to set a primitive PORT tile, don't overwrite an existing
            // object-style PORT (which may contain metadata like portKind: 'stairup').
            if (tile === TILE_TYPES.PORT) {
                const existing = grid[y] && grid[y][x];
                if (existing && typeof existing === 'object' && existing.type === TILE_TYPES.PORT) {
                    // Preserve the object port
                    return;
                }
            }

            grid[y][x] = tile;
        }
    }

    generateZone() {
        const currentZone = this.game.player.getCurrentZone();
        // For underground zones (dimension 2), include the player's depth so each depth layer is stored separately
        const depth = currentZone.depth || (this.game.player.undergroundDepth || 1);
        const zoneKey = createZoneKey(currentZone.x, currentZone.y, currentZone.dimension, depth);

        // Generate chunk connections for current area
        this.game.connectionManager.generateChunkConnections(currentZone.x, currentZone.y);

        // Check if we already have this zone loaded from saved state
        let zoneData;
        // If entering via a port, we must regenerate the zone to ensure the corresponding port exists.
        // This handles cases where a zone was generated without a port, but now needs one.
        const isPortTransition = this.game.lastExitSide === 'port';

        if (this.game.zoneRepository.hasByKey(zoneKey)) {
            // Use existing zone data (loaded from save or previously generated).
            // Previously we forced regeneration for port transitions which could
            // overwrite saved returnToSurface data (e.g. the surface hole where a
            // player fell through). Prefer reusing saved data to preserve that
            // mapping; generators will still patch emergence tiles below when
            // portTransitionData is present.
            zoneData = this.game.zoneRepository.getByKey(zoneKey);
        } else {
            // Generate new zone
            zoneData = this.game.zoneGenerator.generateZone(
                currentZone.x,
                currentZone.y,
                currentZone.dimension,
                this.game.zones,
                this.game.connectionManager.zoneConnections,
                this.game.availableFoodAssets,
                this.game.lastExitSide // Pass how the player entered
            );
            // Defensive: if a zoneGenerator mock or implementation returns falsy,
            // ensure we have a minimal zoneData structure to avoid runtime errors.
            if (!zoneData) {
                zoneData = {
                    grid: this.game.grid || Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(TILE_TYPES.FLOOR)),
                    enemies: [],
                    playerSpawn: null
                };
            }
            // Save the generated zone
            // If we are generating an interior zone as a result of entering via a surface port,
            // persist the surface port coordinates so we can return the player to that exact spot when exiting.
            if (currentZone.dimension === 1 && this.game.portTransitionData?.from === 'interior') {
                zoneData.returnToSurface = { x: this.game.portTransitionData.x, y: this.game.portTransitionData.y };
            }
            // If generating an underground zone as a result of falling through a hole/pitfall,
            // the underground handler may include returnToSurface metadata; ensure it's persisted
            // on the saved zoneData so surface exits can return the player to the exact hole.
            if (currentZone.dimension === 2 && this.game.portTransitionData && (this.game.portTransitionData.from === 'hole' || this.game.portTransitionData.from === 'pitfall')) {
                // Use returnToSurface provided by the generator result if available, otherwise fall back to portTransitionData
                if (!zoneData.returnToSurface) {
                    zoneData.returnToSurface = { x: this.game.portTransitionData.x, y: this.game.portTransitionData.y };
                }
            }
            this.game.zoneRepository.setByKey(zoneKey, zoneData);
        }

        this.game.grid = zoneData.grid;

        // For new games (no lastExitSide), use the playerSpawn from zone generation
        if (!this.game.lastExitSide && zoneData.playerSpawn) {
            // Store the exit tile position for entrance animation
            this.game._newGameSpawnPosition = { ...zoneData.playerSpawn };

            // Position player off-screen (one tile beyond the exit) for entrance animation
            let offScreenX = zoneData.playerSpawn.x;
            let offScreenY = zoneData.playerSpawn.y;

            // Determine off-screen position based on which edge the exit is on
            if (zoneData.playerSpawn.y === 0) {
                // Top edge exit - position player above the grid
                offScreenY = -1;
            } else if (zoneData.playerSpawn.y === GRID_SIZE - 1) {
                // Bottom edge exit - position player below the grid
                offScreenY = GRID_SIZE;
            } else if (zoneData.playerSpawn.x === 0) {
                // Left edge exit - position player to the left of the grid
                offScreenX = -1;
            } else if (zoneData.playerSpawn.x === GRID_SIZE - 1) {
                // Right edge exit - position player to the right of the grid
                offScreenX = GRID_SIZE;
            }

            this.game.player.setPosition(offScreenX, offScreenY);
            logger.log('[ZONE GEN] New game detected, positioning player off-screen at:', { x: offScreenX, y: offScreenY }, 'exit tile at:', zoneData.playerSpawn);
        }

        // If we generated this zone as the result of a port transition, ensure
        // the emergence tile reflects the correct port object (stairup/stairdown)
        try {
            if (this.game.lastExitSide === 'port' && this.game.portTransitionData) {
                const px = this.game.portTransitionData.x;
                const py = this.game.portTransitionData.y;
                const from = this.game.portTransitionData.from;
                if (isWithinGrid(px, py)) {
                    const existing = this.game.grid[py][px];
                    // If transition was from stairdown, we should have a stairup at emergence
                    if (from === 'stairdown') {
                        if (!(existing && typeof existing === 'object' && existing.type === TILE_TYPES.PORT && existing.portKind === 'stairup')) {
                            this.game.grid[py][px] = { type: TILE_TYPES.PORT, portKind: 'stairup' };
                        }
                    } else if (from === 'stairup') {
                        if (!(existing && typeof existing === 'object' && existing.type === TILE_TYPES.PORT && existing.portKind === 'stairdown')) {
                            this.game.grid[py][px] = { type: TILE_TYPES.PORT, portKind: 'stairdown' };
                        }
                    } else if (from === 'cistern') {
                        // ensure cistern top/port is present
                        if (this.game.grid[py + 1] && this.game.grid[py + 1][px] !== TILE_TYPES.CISTERN) {
                            this.validateAndSetTile(this.game.grid, px, py + 1, TILE_TYPES.CISTERN);
                        }
                    } else if (from === 'hole' || from === 'pitfall') {
                        // Only convert a primitive PITFALL/hole into an object-style PORT
                        // (stairup) if the current tile at that location is still a
                        // primitive PITFALL. This prevents accidentally overwriting
                        // unrelated tiles with an up-stair.
                        const existing = this.game.grid[py] && this.game.grid[py][px];
                        const isPrimitivePitfall = existing === TILE_TYPES.PITFALL || existing === TILE_TYPES.HOLE;
                        if (isPrimitivePitfall) {
                            // Convert to an object-style PORT to mark the emergence point
                            this.game.grid[py][px] = { type: TILE_TYPES.PORT, portKind: 'stairup' };
                            try { logger.debug && logger.debug(`Placed stairup at surface (${px},${py}) from ${from}`); } catch (e) {}
                        } else {
                            // Don't overwrite if something else occupies the tile
                            try { logger.debug && logger.debug(`Did not place stairup at (${px},${py}) - existing tile prevents conversion.`); } catch (e) {}
                        }
                        // If an object-style port is already present, leave it as-is.
                    }
                }
            }
        } catch (e) { /* non-fatal */ }
        // When loading enemies, filter out any that are in the defeatedEnemies set.
        const allEnemies = (zoneData.enemies || []).map(e => new this.game.Enemy(e));
        this.game.enemies = allEnemies.filter(enemy => {
            const defeatedKey = `${enemy.id}`;
            return !this.game.defeatedEnemies.has(defeatedKey);
        });


        // Ensure zoneGenerator.grid points to the game grid for methods that need it
        this.game.zoneGenerator.grid = this.game.grid;
    }

    spawnTreasuresOnGrid(treasures) {
        // Spawn treasures on grid at valid floor positions
        for (const treasure of treasures) {
            // Try to place treasure in a valid location (max 50 attempts)
            for (let attempts = 0; attempts < 50; attempts++) {
                const x = Math.floor(Math.random() * (GRID_SIZE - 2)) + 1;
                const y = Math.floor(Math.random() * (GRID_SIZE - 2)) + 1;

                // Check if tile is floor and not occupied or blocked
                const tile = this.game.grid[y][x];
                const isFloorTile = isFloor(tile);
                const isExit = isTileType(tile, TILE_TYPES.EXIT);

                if (isFloorTile && !isExit) {
                    // Place the treasure
                    this.game.grid[y][x] = treasure;
                    break; // Successfully placed
                }
            }
        }

        // Add message to log via event
        eventBus.emit(EventTypes.UI_MESSAGE_LOG, {
            text: 'Treasures found scattered throughout the zone!',
            category: 'treasure',
            priority: 'info',
            timestamp: Date.now()
        });
    }

    saveCurrentZoneState() {
        // Save the current zone's grid and enemies to the zones map
        const currentZone = this.game.player.getCurrentZone();
        const depth = currentZone.depth || (this.game.player.undergroundDepth || 1);
        const zoneKey = createZoneKey(currentZone.x, currentZone.y, currentZone.dimension, depth);

        // Save current zone state to preserve any changes made during gameplay
        this.game.zoneRepository.setByKey(zoneKey, {
            grid: JSON.parse(JSON.stringify(this.game.grid)),
            enemies: [...this.game.enemies.map(enemy => ({
                x: enemy.x,
                y: enemy.y,
                enemyType: enemy.enemyType,
                health: enemy.health,
                id: enemy.id
            }))],
            playerSpawn: null // playerSpawn not needed for current zone
        });

    logger.debug(`Saved current zone state for ${zoneKey}`);
    }
}
